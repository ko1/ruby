/* DO NOT EDIT THIS FILE DIRECTLY: edit template/opt_method.h.tmpl instead */
#ifndef RUBY_OPT_METHOD_H
#define RUBY_OPT_METHOD_H
<%
defs = File.join(File.dirname(File.dirname(erb.filename)), "defs/opt_method.def")
eval(File.read(defs), binding, defs)
tmasks = []
%>
typedef uint<%= OM_ALIGN %>_t rb_om_bitmap_t;

enum ruby_optimized_method {
<%
opt_masks = {}
mask_classes = {}
n = 0
OPT_METHODS.each do |(mid, *classes)|
  classes.each do |klass|
    if Array === klass
      opt_masks[mid] = klass.dup
      # we will align these in the second loop, below
      klass.each { |k| mask_classes[k] = true }
      next
    end %>
    <%= om(mid, klass) %> = <%= n += 1 %>,
<%
  end # classes.each
end # OPT_METHODS.each

# align multi-class bits so a single AND operation may
# be byte-aligned and used to check an mid for up to 7 classes at once:
opt_masks.each do |mid, classes|
  # round up n to the next aligned byte slot
  n = (n + OM_ALIGN) & OM_ALIGN_MASK

  classes.each do |k|
%>
    <%= om(mid, k) %> = <%= n += 1 %>,
<%=
# we need this macro to generate shifts for the masks enums below:
"#define #{om(mid, k)} (#{n})"
%>
<%
  end # classes.each
end # opt_masks.each
if n >= ((1 << OM_ALIGN) - 1)
  raise "OM_ALIGN needs to be raised to support more optimized methods"
end
%>
    OM_LAST_ = <%= om_last = (n += 1) %>, /* for bitmap sizing */
    /* special mask values below */
<%
# generate mask enums
opt_masks.each do |mid, c|
  # n.b.: negate masks to simplify the rb_opt_method_is_mask check:
%>
    <%= om(mid, c) %> = (unsigned int)(-(<%=
      # pack into 16 bits so it may be a negative Fixnum
      # 1) 8 byte offset
      # 2) OM_ALIGN bytes mask (8 or 16)
      sep = "|\n    "
      "/* offset: */ ((#{om(mid, c[0])} / #{OM_ALIGN}) << #{OM_ALIGN}) " \
      "#{sep} /* mask: */ (" +
      c.map { |k| "(1U << (#{om(mid, k)} % #{OM_ALIGN}))" }.join(sep) + # mask
      ')'
  %>)),
<%
  # mask for type checking in insns.def, we name this like the OM_*
  # enum so it is easy to get this name using CPP macros
  tmasks << [
    "OM_TMASK_#{c.join('_')}",
    'INT2FIX(' +
      c.map {|k| "(1U << RUBY_T_#{k.upcase})" }.join("|\\\n\t") +
      ')'
  ]
end # opt_masks.each
opt_classes.each_key do |k|
  if IS_T_DATA[k]
    tmasks << [ "OM_TMASK_#{k}", "rb_c#{k}" ]
  else
    tmasks << [ "OM_TMASK_#{k}", "INT2FIX(1U << RUBY_T_#{k.upcase})" ]
  end
end # opt_classes.each_key
%>
    OM_ALIGN_ = <%= OM_ALIGN %>,
    OM_SIZE_ = <%= ((om_last + OM_ALIGN) & OM_ALIGN_MASK) / OM_ALIGN %>,
    OM_GETMASK_ = (1 << OM_ALIGN_) - 1
};

/* macros */
<% tmasks.each do |(k,v)| %>
#define <%= k %> (<%= v %>)
<% end %>

/* map a raw type to the preferred (optimized) class */
static inline VALUE
rb_opt_method_class(enum ruby_value_type type)
{
    switch (type) {
<%
opt_classes.each_key do |k|
  next if IS_T_DATA[k]
%>
      case RUBY_T_<%= k.upcase %>: return rb_c<%= k %>;
<%
end
%>
      default: return Qfalse;
    }
}

#endif /* RUBY_OPT_METHOD_H */
